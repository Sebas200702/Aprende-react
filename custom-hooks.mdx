---
title: "Custom Hooks"
description: "Crea tus propios hooks para reutilizar l√≥gica en toda tu aplicaci√≥n"
---

# Custom Hooks: Tu propia magia ‚ú®

Los **custom hooks** son hooks que t√∫ mismo creas para **reutilizar l√≥gica** entre componentes. Son como crear tus propias herramientas especializadas.

## ¬øQu√© son los custom hooks?

<Info>
  **Piensa en ello as√≠**: Si los hooks son aplicaciones en tu tel√©fono, los custom hooks son como **atajos de Siri** que creas t√∫ mismo. Combinas varias acciones en una sola que puedes usar donde quieras.
</Info>

**Sin custom hook (c√≥digo repetido):**
```tsx
// Componente A
const [cargando, setCargando] = useState<boolean>(false);
const [datos, setDatos] = useState(null);
useEffect(() => { fetch(url)... }, []);

// Componente B  
const [cargando, setCargando] = useState<boolean>(false);
const [datos, setDatos] = useState(null);
useEffect(() => { fetch(url)... }, []); // ¬°Mismo c√≥digo!
```

**Con custom hook (reutilizable):**
```tsx
// Componente A
const { datos, cargando } = useFetch(url);

// Componente B
const { datos, cargando } = useFetch(url); // ¬°Mismo hook!
```

## Reglas de custom hooks

1. **Nombre con "use"**: Siempre empieza con `use` (useLocalStorage, useFetch, useAuth)
2. **Puede usar otros hooks**: Combina useState, useEffect, etc.
3. **Retorna lo que necesites**: Puede ser un valor, objeto, array, funci√≥n, etc.

## Tu primer custom hook

### Ejemplo: useContador

```tsx
import { useState } from 'react';

const useContador = (inicial: number = 0) => {
  const [cuenta, setCuenta] = useState<number>(inicial);
  
  const incrementar = () => setCuenta(cuenta + 1);
  const decrementar = () => setCuenta(cuenta - 1);
  const reiniciar = () => setCuenta(inicial);
  
  return { cuenta, incrementar, decrementar, reiniciar };
};

// Uso
const Componente = () => {
  const { cuenta, incrementar, decrementar, reiniciar } = useContador(10);
  
  return (
    <div>
      <p>Cuenta: {cuenta}</p>
      <button onClick={incrementar}>+</button>
      <button onClick={decrementar}>-</button>
      <button onClick={reiniciar}>Reiniciar</button>
    </div>
  );
};
```

<Tip>
  ¬øVes? Encapsulaste toda la l√≥gica del contador en un hook. Ahora puedes usarlo en cualquier componente.
</Tip>

## Custom hooks √∫tiles

### 1. useFetch: Cargar datos

```tsx
import { useState, useEffect } from 'react';

interface UseFetchResult<T> {
  datos: T | null;
  cargando: boolean;
  error: Error | null;
}

const useFetch = <T,>(url: string): UseFetchResult<T> => {
  const [datos, setDatos] = useState<T | null>(null);
  const [cargando, setCargando] = useState<boolean>(true);
  const [error, setError] = useState<Error | null>(null);
  
  useEffect(() => {
    setCargando(true);
    setError(null);
    
    fetch(url)
      .then(res => {
        if (!res.ok) throw new Error('Error en la petici√≥n');
        return res.json();
      })
      .then(data => {
        setDatos(data);
        setCargando(false);
      })
      .catch(err => {
        setError(err);
        setCargando(false);
      });
  }, [url]);
  
  return { datos, cargando, error };
};

// Uso
interface Usuario {
  id: number;
  nombre: string;
  email: string;
}

const PerfilUsuario = ({ userId }: { userId: number }) => {
  const { datos, cargando, error } = useFetch<Usuario>(
    `/api/usuarios/${userId}`
  );
  
  if (cargando) return <p>Cargando...</p>;
  if (error) return <p>Error: {error.message}</p>;
  if (!datos) return <p>No hay datos</p>;
  
  return (
    <div>
      <h2>{datos.nombre}</h2>
      <p>{datos.email}</p>
    </div>
  );
};
```

### 2. useLocalStorage: Persistir datos

```tsx
import { useState, useEffect } from 'react';

const useLocalStorage = <T,>(key: string, valorInicial: T) => {
  // Obtener valor guardado o usar inicial
  const [valor, setValor] = useState<T>(() => {
    try {
      const item = window.localStorage.getItem(key);
      return item ? JSON.parse(item) : valorInicial;
    } catch (error) {
      console.error(error);
      return valorInicial;
    }
  });
  
  // Guardar en localStorage cuando cambie
  useEffect(() => {
    try {
      window.localStorage.setItem(key, JSON.stringify(valor));
    } catch (error) {
      console.error(error);
    }
  }, [key, valor]);
  
  return [valor, setValor] as const;
};

// Uso
const Preferencias = () => {
  const [tema, setTema] = useLocalStorage<'claro' | 'oscuro'>('tema', 'claro');
  const [idioma, setIdioma] = useLocalStorage<string>('idioma', 'es');
  
  return (
    <div>
      <button onClick={() => setTema(tema === 'claro' ? 'oscuro' : 'claro')}>
        Cambiar tema (actual: {tema})
      </button>
      <button onClick={() => setIdioma(idioma === 'es' ? 'en' : 'es')}>
        Cambiar idioma (actual: {idioma})
      </button>
    </div>
  );
};
```

<Info>
  Los datos se guardan autom√°ticamente en el navegador. Si refrescas la p√°gina, ¬°siguen ah√≠!
</Info>

### 3. useToggle: Alternar boolean

```tsx
import { useState } from 'react';

const useToggle = (inicial: boolean = false): [boolean, () => void] => {
  const [valor, setValor] = useState<boolean>(inicial);
  
  const toggle = () => setValor(v => !v);
  
  return [valor, toggle];
};

// Uso
const Menu = () => {
  const [abierto, toggleAbierto] = useToggle(false);
  const [modoOscuro, toggleModoOscuro] = useToggle(true);
  
  return (
    <div>
      <button onClick={toggleAbierto}>
        {abierto ? 'Cerrar' : 'Abrir'} men√∫
      </button>
      {abierto && (
        <nav>
          <a href="/">Inicio</a>
          <a href="/about">Acerca de</a>
        </nav>
      )}
      
      <button onClick={toggleModoOscuro}>
        Modo {modoOscuro ? 'oscuro' : 'claro'}
      </button>
    </div>
  );
};
```

### 4. useDebounce: Retrasar actualizaciones

√ötil para b√∫squedas en tiempo real (no hacer peticiones en cada tecla).

```tsx
import { useState, useEffect } from 'react';

const useDebounce = <T,>(valor: T, delay: number): T => {
  const [valorDebounced, setValorDebounced] = useState<T>(valor);
  
  useEffect(() => {
    // Establecer timeout para actualizar despu√©s del delay
    const handler = setTimeout(() => {
      setValorDebounced(valor);
    }, delay);
    
    // Limpiar timeout si valor cambia antes del delay
    return () => {
      clearTimeout(handler);
    };
  }, [valor, delay]);
  
  return valorDebounced;
};

// Uso: B√∫squeda con debounce
const BuscadorProductos = () => {
  const [busqueda, setBusqueda] = useState<string>('');
  const busquedaDebounced = useDebounce(busqueda, 500); // 500ms de retraso
  const { datos } = useFetch(`/api/productos?q=${busquedaDebounced}`);
  
  return (
    <div>
      <input
        value={busqueda}
        onChange={(e) => setBusqueda(e.target.value)}
        placeholder="Buscar productos..."
      />
      {/* Solo busca despu√©s de 500ms sin escribir */}
      <ul>
        {datos?.map((producto: any) => (
          <li key={producto.id}>{producto.nombre}</li>
        ))}
      </ul>
    </div>
  );
};
```

<Note>
  **Debounce** espera a que el usuario deje de escribir antes de hacer la b√∫squeda. ¬°Ahorra recursos!
</Note>

### 5. useWindowSize: Tama√±o de ventana

```tsx
import { useState, useEffect } from 'react';

interface WindowSize {
  width: number;
  height: number;
}

const useWindowSize = (): WindowSize => {
  const [windowSize, setWindowSize] = useState<WindowSize>({
    width: window.innerWidth,
    height: window.innerHeight,
  });
  
  useEffect(() => {
    const handleResize = () => {
      setWindowSize({
        width: window.innerWidth,
        height: window.innerHeight,
      });
    };
    
    window.addEventListener('resize', handleResize);
    
    return () => window.removeEventListener('resize', handleResize);
  }, []);
  
  return windowSize;
};

// Uso
const ResponsiveComponent = () => {
  const { width, height } = useWindowSize();
  
  return (
    <div>
      <p>Ancho: {width}px</p>
      <p>Alto: {height}px</p>
      {width < 768 ? (
        <p>Est√°s en m√≥vil üì±</p>
      ) : (
        <p>Est√°s en desktop üñ•Ô∏è</p>
      )}
    </div>
  );
};
```

### 6. useForm: Manejar formularios

```tsx
import { useState, ChangeEvent, FormEvent } from 'react';

const useForm = <T extends Record<string, any>>(valoresIniciales: T) => {
  const [valores, setValores] = useState<T>(valoresIniciales);
  
  const handleChange = (e: ChangeEvent<HTMLInputElement>) => {
    const { name, value, type, checked } = e.target;
    setValores({
      ...valores,
      [name]: type === 'checkbox' ? checked : value
    });
  };
  
  const reiniciar = () => setValores(valoresIniciales);
  
  return { valores, handleChange, reiniciar };
};

// Uso
interface FormularioLogin {
  email: string;
  password: string;
  recordar: boolean;
}

const LoginForm = () => {
  const { valores, handleChange, reiniciar } = useForm<FormularioLogin>({
    email: '',
    password: '',
    recordar: false
  });
  
  const handleSubmit = (e: FormEvent) => {
    e.preventDefault();
    console.log('Enviando:', valores);
    reiniciar();
  };
  
  return (
    <form onSubmit={handleSubmit}>
      <input
        name="email"
        type="email"
        value={valores.email}
        onChange={handleChange}
        placeholder="Email"
      />
      <input
        name="password"
        type="password"
        value={valores.password}
        onChange={handleChange}
        placeholder="Contrase√±a"
      />
      <label>
        <input
          name="recordar"
          type="checkbox"
          checked={valores.recordar}
          onChange={handleChange}
        />
        Recordarme
      </label>
      <button type="submit">Iniciar sesi√≥n</button>
    </form>
  );
};
```

### 7. useAsync: Manejar operaciones as√≠ncronas

```tsx
import { useState, useEffect, useCallback } from 'react';

interface UseAsyncResult<T> {
  ejecutar: () => Promise<void>;
  datos: T | null;
  cargando: boolean;
  error: Error | null;
}

const useAsync = <T,>(
  asyncFunction: () => Promise<T>,
  inmediato: boolean = true
): UseAsyncResult<T> => {
  const [datos, setDatos] = useState<T | null>(null);
  const [cargando, setCargando] = useState<boolean>(inmediato);
  const [error, setError] = useState<Error | null>(null);
  
  const ejecutar = useCallback(async () => {
    setCargando(true);
    setError(null);
    
    try {
      const resultado = await asyncFunction();
      setDatos(resultado);
    } catch (err) {
      setError(err as Error);
    } finally {
      setCargando(false);
    }
  }, [asyncFunction]);
  
  useEffect(() => {
    if (inmediato) {
      ejecutar();
    }
  }, [ejecutar, inmediato]);
  
  return { ejecutar, datos, cargando, error };
};

// Uso
const BotonCargarDatos = () => {
  const fetchDatos = () => 
    fetch('/api/datos').then(res => res.json());
  
  const { ejecutar, datos, cargando, error } = useAsync(fetchDatos, false);
  
  return (
    <div>
      <button onClick={ejecutar} disabled={cargando}>
        {cargando ? 'Cargando...' : 'Cargar datos'}
      </button>
      {error && <p>Error: {error.message}</p>}
      {datos && <pre>{JSON.stringify(datos, null, 2)}</pre>}
    </div>
  );
};
```

## Composici√≥n de custom hooks

Puedes combinar custom hooks para crear funcionalidades m√°s complejas:

```tsx
interface Usuario {
  nombre: string;
}

const useUsuarioAutenticado = () => {
  const { datos: usuario, cargando } = useFetch<Usuario>('/api/usuario');
  const [sesionActiva, setSesionActiva] = useLocalStorage<boolean>('sesion', false);
  
  useEffect(() => {
    if (usuario) {
      setSesionActiva(true);
    }
  }, [usuario, setSesionActiva]);
  
  const cerrarSesion = () => {
    setSesionActiva(false);
    // L√≥gica adicional de logout
  };
  
  return { usuario, cargando, sesionActiva, cerrarSesion };
};

// Uso
const Header = () => {
  const { usuario, cargando, cerrarSesion } = useUsuarioAutenticado();
  
  if (cargando) return <p>Cargando...</p>;
  
  return (
    <header>
      {usuario ? (
        <>
          <p>Hola, {usuario.nombre}</p>
          <button onClick={cerrarSesion}>Cerrar sesi√≥n</button>
        </>
      ) : (
        <button>Iniciar sesi√≥n</button>
      )}
    </header>
  );
};
```

## Mejores pr√°cticas

<CardGroup cols={2}>
  <Card title="Un prop√≥sito claro" icon="bullseye">
    Cada hook debe hacer una cosa espec√≠fica
  </Card>
  <Card title="Nombre descriptivo" icon="tag">
    `useProductosEnOferta` es mejor que `useData`
  </Card>
  <Card title="Documenta par√°metros" icon="book">
    Explica qu√© recibe y qu√© retorna el hook
  </Card>
  <Card title="Maneja errores" icon="shield-exclamation">
    Siempre incluye manejo de errores en operaciones async
  </Card>
</CardGroup>

## Estructura de carpetas recomendada

```
src/
‚îú‚îÄ‚îÄ hooks/
‚îÇ   ‚îú‚îÄ‚îÄ useContador.ts
‚îÇ   ‚îú‚îÄ‚îÄ useFetch.ts
‚îÇ   ‚îú‚îÄ‚îÄ useLocalStorage.ts
‚îÇ   ‚îú‚îÄ‚îÄ useDebounce.ts
‚îÇ   ‚îú‚îÄ‚îÄ useForm.ts
‚îÇ   ‚îî‚îÄ‚îÄ index.ts  // Re-exporta todos los hooks
‚îú‚îÄ‚îÄ components/
‚îî‚îÄ‚îÄ App.tsx
```

```typescript
// hooks/index.ts
export { default as useContador } from './useContador';
export { default as useFetch } from './useFetch';
export { default as useLocalStorage } from './useLocalStorage';
export { default as useDebounce } from './useDebounce';
export { default as useForm } from './useForm';
```

Importaci√≥n simplificada:
```tsx
import { useFetch, useLocalStorage, useForm } from './hooks';
```

## Testing de custom hooks

```tsx
import { renderHook, act } from '@testing-library/react';
import { useContador } from './useContador';

test('useContador incrementa correctamente', () => {
  const { result } = renderHook(() => useContador(0));
  
  expect(result.current.cuenta).toBe(0);
  
  act(() => {
    result.current.incrementar();
  });
  
  expect(result.current.cuenta).toBe(1);
});
```

---

## Pr√≥ximo paso

Ya dominas los hooks personalizados. Ahora aprende a manejar el **estado global** de tu aplicaci√≥n de forma simple con **Zustand**.

<Card title="Aprende Zustand" icon="database" href="/zustand">
  Descubre c√≥mo manejar el estado de forma elegante ‚Üí
</Card>
